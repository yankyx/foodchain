<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é£Ÿç‰©é“¾æ­å»ºæ¨¡æ‹Ÿå™¨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#165DFF',
                        secondary: '#36CFC9',
                        accent: '#722ED1',
                        warning: '#FF7D00',
                        danger: '#F53F3F',
                        success: '#00B42A',
                        neutral: '#86909C',
                    },
                    fontFamily: {
                        inter: ['Inter', 'sans-serif'],
                    },
                },
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .drag-item {
                @apply cursor-move transition-all duration-200 hover:scale-110 hover:shadow-lg;
            }
            .drop-zone {
                @apply border-2 border-dashed border-primary/30 transition-all duration-200;
            }
            .drop-zone-active {
                @apply border-primary bg-primary/5;
            }
            .creature-icon {
                @apply flex items-center justify-center w-14 h-14 text-3xl bg-white rounded-full shadow-md transition-all duration-300 hover:shadow-lg;
            }
            .btn-level {
                @apply px-3 py-2 rounded-md transition-all duration-200 text-sm font-medium;
            }
            .btn-level-active {
                @apply bg-primary text-white;
            }
            .btn-level-inactive {
                @apply bg-gray-100 text-gray-600 hover:bg-gray-200;
            }
        }
        :host, html {
            -webkit-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }
    </style>
</head>
<body class="font-inter bg-gray-50 min-h-screen flex flex-col overflow-hidden">
    <header class="bg-white shadow-sm py-3 px-4 sm:px-6 lg:px-8 flex items-center justify-between z-10">
        <div class="flex items-center space-x-2">
            <i class="fa fa-link text-primary text-xl"></i>
            <h1 class="text-[clamp(1.2rem,3vw,1.8rem)] font-bold text-gray-900">é£Ÿç‰©é“¾æ­å»ºæ¨¡æ‹Ÿå™¨</h1>
        </div>
        <div id="info-panel" class="text-sm text-gray-600 bg-blue-50 px-3 py-1.5 rounded-md hidden items-center space-x-1 max-w-xs">
            <i class="fa fa-info-circle text-primary"></i>
            <span id="info-message">å°†è¢«æ•é£Ÿè€…æ‹–æ‹½åˆ°æ•é£Ÿè€…ä¸Šå»ºç«‹å…³ç³»</span>
        </div>
    </header>

    <main class="flex-1 flex flex-col md:flex-row overflow-hidden p-3 md:p-4 gap-3">
        <div class="w-full md:w-72 bg-white rounded-lg shadow-sm p-4 flex flex-col gap-4 overflow-hidden">
            <div class="space-y-2">
                <h2 class="text-lg font-semibold text-gray-800 flex items-center">
                    <i class="fa fa-list-ol text-primary mr-2"></i>å…³å¡é€‰æ‹©
                </h2>
                <div id="level-selector" class="grid grid-cols-5 gap-2 max-h-28 overflow-y-auto p-1 bg-gray-50 rounded-md">
                    </div>
                <button id="check-btn" class="w-full mt-2 bg-primary hover:bg-primary/90 text-white py-2 rounded-md transition-all duration-200 flex items-center justify-center gap-2">
                    <i class="fa fa-check-circle"></i>
                    <span>æ£€æŸ¥é£Ÿç‰©é“¾</span>
                </button>
            </div>

            <div class="flex-1 flex flex-col overflow-hidden">
                <h2 class="text-lg font-semibold text-gray-800 flex items-center mb-2">
                    <i class="fa fa-paw text-primary mr-2"></i>å¯ç”¨ç”Ÿç‰©
                </h2>
                <div id="creatures-container" class="flex-1 grid grid-cols-3 sm:grid-cols-4 gap-2 p-2 bg-gray-50 rounded-md overflow-y-auto">
                    </div>
            </div>
        </div>

        <div class="flex-1 bg-white rounded-lg shadow-sm p-3 overflow-hidden flex flex-col">
            <h2 class="text-lg font-semibold text-gray-800 flex items-center mb-2 px-2">
                <i class="fa fa-draw-polygon text-primary mr-2"></i>ç”»å¸ƒåŒºåŸŸ
            </h2>
            <div id="canvas" class="flex-1 drop-zone rounded-md relative overflow-auto bg-gray-50">
                </div>
            <div class="mt-2 text-xs text-gray-500 flex items-center justify-between px-2">
                <span>æç¤º: ä»å·¦ä¾§æ‹–æ‹½ç”Ÿç‰©åˆ°ç”»å¸ƒï¼Œç„¶åå°†è¢«æ•é£Ÿè€…æ‹–æ‹½åˆ°æ•é£Ÿè€…ä¸Š</span>
                <span id="level-info">å½“å‰å…³å¡: ç¬¬1å…³</span>
            </div>
        </div>
    </main>

    <footer class="bg-white shadow-sm py-2 px-4 text-sm text-gray-500 flex items-center justify-between">
        <div>é£Ÿç‰©é“¾æ­å»ºæ¨¡æ‹Ÿå™¨ &copy; 2023</div>
        <div id="status-bar">å‡†å¤‡å°±ç»ª</div>
    </footer>

    <script>
        const creaturesData = [
            { id: 1, name: 'è‰', emoji: 'ğŸŒ¿', type: 'producer', prey: [] }, { id: 2, name: 'å…”å­', emoji: 'ğŸ°', type: 'consumer', prey: [1] }, { id: 3, name: 'ç‹ç‹¸', emoji: 'ğŸ¦Š', type: 'consumer', prey: [2] }, { id: 4, name: 'ç‹®å­', emoji: 'ğŸ¦', type: 'consumer', prey: [2, 3] }, { id: 5, name: 'è€é¼ ', emoji: 'ğŸ­', type: 'consumer', prey: [1] }, { id: 6, name: 'è›‡', emoji: 'ğŸ', type: 'consumer', prey: [2, 5] }, { id: 7, name: 'é¹°', emoji: 'ğŸ¦…', type: 'consumer', prey: [2, 5, 6] }, { id: 8, name: 'èš‚èš', emoji: 'ğŸœ', type: 'consumer', prey: [1] }, { id: 9, name: 'èœ˜è››', emoji: 'ğŸ•·ï¸', type: 'consumer', prey: [8] }, { id: 10, name: 'é¸Ÿ', emoji: 'ğŸ¦', type: 'consumer', prey: [8] }, { id: 11, name: 'é±¼', emoji: 'ğŸŸ', type: 'consumer', prey: [12] }, { id: 12, name: 'æµ®æ¸¸ç”Ÿç‰©', emoji: 'ğŸ¦ ', type: 'producer', prey: [] }, { id: 13, name: 'é’è›™', emoji: 'ğŸ¸', type: 'consumer', prey: [8, 10] }, { id: 14, name: 'é³„é±¼', emoji: 'ğŸŠ', type: 'consumer', prey: [2, 13, 15] }, { id: 15, name: 'é¹¿', emoji: 'ğŸ¦Œ', type: 'consumer', prey: [1] }, { id: 16, name: 'ç‹¼', emoji: 'ğŸº', type: 'consumer', prey: [2, 15] }, { id: 17, name: 'ç†Š', emoji: 'ğŸ»', type: 'consumer', prey: [2, 3, 15] }, { id: 18, name: 'èœœèœ‚', emoji: 'ğŸ', type: 'consumer', prey: [1] }, { id: 19, name: 'è´è¶', emoji: 'ğŸ¦‹', type: 'consumer', prey: [1] }, { id: 20, name: 'çŒ«å¤´é¹°', emoji: 'ğŸ¦‰', type: 'consumer', prey: [5, 9] }, { id: 21, name: 'èœˆèš£', emoji: 'ğŸ›', type: 'consumer', prey: [8] }, { id: 22, name: 'èœ¥èœ´', emoji: 'ğŸ¦', type: 'consumer', prey: [8, 21] }, { id: 23, name: 'é¾Ÿ', emoji: 'ğŸ¢', type: 'consumer', prey: [12, 11] }, { id: 24, name: 'è™¾', emoji: 'ğŸ¦', type: 'consumer', prey: [12] }, { id: 25, name: 'èŸ¹', emoji: 'ğŸ¦€', type: 'consumer', prey: [12, 24] }, { id: 26, name: 'ç« é±¼', emoji: 'ğŸ™', type: 'consumer', prey: [11, 24, 25] }, { id: 27, name: 'æµ·é¸Ÿ', emoji: 'ğŸ¦â€â¬›', type: 'consumer', prey: [11, 24] }, { id: 28, name: 'è±¹å­', emoji: 'ğŸ†', type: 'consumer', prey: [2, 15] }, { id: 29, name: 'å¤§è±¡', emoji: 'ğŸ˜', type: 'consumer', prey: [1] }, { id: 30, name: 'çŠ€ç‰›', emoji: 'ğŸ¦', type: 'consumer', prey: [1] }, { id: 31, name: 'æ²³é©¬', emoji: 'ğŸ¦›', type: 'consumer', prey: [1] }, { id: 32, name: 'é•¿é¢ˆé¹¿', emoji: 'ğŸ¦’', type: 'consumer', prey: [1] }, { id: 33, name: 'æ–‘é©¬', emoji: 'ğŸ¦“', type: 'consumer', prey: [1] }, { id: 34, name: 'çŒ´å­', emoji: 'ğŸ’', type: 'consumer', prey: [1] }, { id: 35, name: 'çŒ©çŒ©', emoji: 'ğŸ¦§', type: 'consumer', prey: [1] }, { id: 36, name: 'ç†ŠçŒ«', emoji: 'ğŸ¼', type: 'consumer', prey: [1] }, { id: 37, name: 'è¢‹é¼ ', emoji: 'ğŸ¦˜', type: 'consumer', prey: [1] }, { id: 38, name: 'è€ƒæ‹‰', emoji: 'ğŸ¨', type: 'consumer', prey: [1] }, { id: 39, name: 'ä¼é¹…', emoji: 'ğŸ§', type: 'consumer', prey: [11, 24] }, { id: 40, name: 'é²¸é±¼', emoji: 'ğŸ‹', type: 'consumer', prey: [11, 24, 26] }
        ];

        // --- ã€ä¿®æ”¹ã€‘ å…³å¡ç”Ÿæˆé€»è¾‘ ---

        /**
         * æ£€æŸ¥ä¸€ä¸ªç”Ÿç‰©åœ¨ç»™å®šçš„ç”Ÿç‰©IDé›†åˆä¸­æ˜¯å¦æ˜¯å­¤ç«‹çš„
         * @param {number} creatureId - è¦æ£€æŸ¥çš„ç”Ÿç‰©ID
         * @param {Set<number>} creatureIdSet - å½“å‰å…³å¡çš„ç”Ÿç‰©IDé›†åˆ
         * @returns {boolean} - å¦‚æœæ˜¯å­¤ç«‹çš„ï¼Œè¿”å›true
         */
        function isCreatureIsolated(creatureId, creatureIdSet) {
            const creature = creaturesData.find(c => c.id === creatureId);
            if (!creature) return true;

            // æ£€æŸ¥å®ƒæ˜¯å¦èƒ½æ•é£Ÿé›†åˆä¸­çš„ä»»ä½•ç”Ÿç‰©
            const canEat = creature.prey.some(preyId => creatureIdSet.has(preyId));
            if (canEat) return false;

            // æ£€æŸ¥å®ƒæ˜¯å¦èƒ½è¢«é›†åˆä¸­çš„ä»»ä½•ç”Ÿç‰©æ•é£Ÿ
            const isEaten = creaturesData.some(predator =>
                creatureIdSet.has(predator.id) && predator.prey.includes(creatureId)
            );
            if (isEaten) return false;

            return true;
        }

        /**
         * ç”Ÿæˆæ‰€æœ‰å…³å¡çš„æ•°æ®
         * @returns {Array<object>} - åŒ…å«10ä¸ªå…³å¡å¯¹è±¡çš„æ•°ç»„
         */
        function generateLevels() {
            const generatedLevels = [];

            for (let i = 0; i < 10; i++) {
                const levelNum = i + 1;
                const creatureCount = 4 + i * 2;
                let creatureIds = [];

                if (levelNum === 1) {
                    // ç¬¬ä¸€å…³ä¿æŒå›ºå®š
                    creatureIds = creaturesData.slice(0, creatureCount).map(c => c.id);
                } else {
                    // å…³å¡ 2-10 è¿›è¡Œéšæœºç”Ÿæˆ
                    let attempts = 0;
                    while(attempts < 50) { // è®¾ç½®å°è¯•æ¬¡æ•°ä¸Šé™ï¼Œé˜²æ­¢æ­»å¾ªç¯
                        const availableCreatures = [...creaturesData];
                        const selectedCreatures = new Set();

                        // 1. éšæœºé€‰æ‹©ä¸€ä¸ªâ€œç§å­â€ç”Ÿç‰©
                        const startIndex = Math.floor(Math.random() * availableCreatures.length);
                        selectedCreatures.add(availableCreatures.splice(startIndex, 1)[0].id);

                        // 2. å¾ªç¯æ‰©å¼ é£Ÿç‰©ç½‘ï¼Œç›´åˆ°æ•°é‡è¾¾æ ‡
                        while (selectedCreatures.size < creatureCount && availableCreatures.length > 0) {
                            // 3. æ‰¾åˆ°æ‰€æœ‰ä¸å·²é€‰ç”Ÿç‰©æœ‰å…³è”çš„â€œå€™é€‰è€…â€
                            const candidates = availableCreatures.filter(candidate => {
                                // A) å€™é€‰è€…èƒ½åƒæ‰å·²é€‰ä¸­çš„ç”Ÿç‰©
                                const eatsSelected = candidate.prey.some(preyId => selectedCreatures.has(preyId));
                                // B) å€™é€‰è€…èƒ½è¢«å·²é€‰ä¸­çš„ç”Ÿç‰©åƒæ‰
                                const eatenBySelected = creaturesData.some(predator =>
                                    selectedCreatures.has(predator.id) && predator.prey.includes(candidate.id)
                                );
                                return eatsSelected || eatenBySelected;
                            });

                            let nextCreature;
                            if (candidates.length > 0) {
                                // 4. ä»æœ‰å…³è”çš„å€™é€‰è€…ä¸­éšæœºé€‰ä¸€ä¸ª
                                const candidateIndex = Math.floor(Math.random() * candidates.length);
                                nextCreature = candidates[candidateIndex];
                            } else {
                                // 5. å¦‚æœæ²¡æœ‰å…³è”è€…äº†ï¼ˆé˜²æ­¢ç”Ÿæˆæ–­å¼€çš„é£Ÿç‰©ç½‘ï¼‰ï¼Œä»å‰©ä½™æ‰€æœ‰ç”Ÿç‰©ä¸­éšæœºé€‰ä¸€ä¸ªæ¥â€œæ­æ¡¥â€
                                const fallbackIndex = Math.floor(Math.random() * availableCreatures.length);
                                nextCreature = availableCreatures[fallbackIndex];
                            }

                            selectedCreatures.add(nextCreature.id);
                            const indexInAvailable = availableCreatures.findIndex(c => c.id === nextCreature.id);
                            if (indexInAvailable > -1) {
                                availableCreatures.splice(indexInAvailable, 1);
                            }
                        }

                        // 6. æœ€ç»ˆæ ¡éªŒï¼Œç¡®ä¿æ²¡æœ‰å­¤ç«‹èŠ‚ç‚¹
                        const finalIds = Array.from(selectedCreatures);
                        const hasIsolated = finalIds.some(id => isCreatureIsolated(id, selectedCreatures));

                        if (!hasIsolated) {
                            creatureIds = finalIds;
                            break; // ç”ŸæˆæˆåŠŸï¼Œè·³å‡ºå°è¯•å¾ªç¯
                        }
                        attempts++;
                    }

                    // å¦‚æœå°è¯•å¤šæ¬¡ä»å¤±è´¥ï¼Œåˆ™ä½¿ç”¨ä¿åº•çš„å›ºå®šç”Ÿæˆæ³•
                    if (creatureIds.length === 0) {
                        creatureIds = creaturesData.slice(0, creatureCount).map(c => c.id);
                    }
                }

                generatedLevels.push({
                    level: levelNum,
                    creatureCount: creatureCount,
                    creatureIds: creatureIds
                });
            }
            return generatedLevels;
        }

        // ã€ä¿®æ”¹ã€‘è°ƒç”¨æ–°çš„å…³å¡ç”Ÿæˆå‡½æ•°
        const levels = generateLevels();

        // --- æ¸¸æˆçŠ¶æ€å’ŒDOMå…ƒç´ ï¼ˆæ— ä¿®æ”¹ï¼‰ ---
        const gameState = {
            currentLevel: 1,
            canvasCreatures: new Map(),
            connections: new Set(),
            draggingElement: null,
            draggedCreatureId: null
        };
        const levelSelector = document.getElementById('level-selector');
        const creaturesContainer = document.getElementById('creatures-container');
        const canvas = document.getElementById('canvas');
        const checkBtn = document.getElementById('check-btn');
        const statusBar = document.getElementById('status-bar');
        const levelInfo = document.getElementById('level-info');
        const infoPanel = document.getElementById('info-panel');
        const infoMessage = document.getElementById('info-message');

        // --- ä»¥ä¸‹æ‰€æœ‰æ¸¸æˆæ ¸å¿ƒå‡½æ•°å‡æ— éœ€ä¿®æ”¹ ---
        function initLevelSelector() {
            levelSelector.innerHTML = '';
            levels.forEach(level => {
                const button = document.createElement('button');
                button.className = `btn-level ${level.level === gameState.currentLevel ? 'btn-level-active' : 'btn-level-inactive'}`;
                button.textContent = level.level;
                button.addEventListener('click', () => { if (level.level !== gameState.currentLevel) switchLevel(level.level); });
                levelSelector.appendChild(button);
            });
        }

        function switchLevel(levelNum) {
            if (levelNum < 1 || levelNum > levels.length) return;
            canvas.innerHTML = '';
            gameState.canvasCreatures.clear();
            gameState.connections.clear();
            gameState.currentLevel = levelNum;
            levelInfo.textContent = `å½“å‰å…³å¡: ç¬¬${levelNum}å…³`;
            document.querySelectorAll('.btn-level').forEach((btn, i) => {
                btn.className = `btn-level ${(i + 1) === levelNum ? 'btn-level-active' : 'btn-level-inactive'}`;
            });
            updateCreaturesContainer();
            const creatureCount = levels[levelNum - 1].creatureIds.length;
            showStatus(`å·²åˆ‡æ¢åˆ°ç¬¬${levelNum}å…³ï¼ŒåŒ…å«${creatureCount}ç§ç”Ÿç‰©`);
        }

        function updateCreaturesContainer() {
            creaturesContainer.innerHTML = '';
            const currentLevelCreatures = levels[gameState.currentLevel - 1].creatureIds;
            creaturesData
                .filter(creature => currentLevelCreatures.includes(creature.id))
                .forEach(creature => {
                    const creatureElement = createCreatureElement(creature, false);
                    creatureElement.classList.add('drag-item');
                    creatureElement.setAttribute('draggable', 'true');
                    creatureElement.addEventListener('dragstart', (e) => {
                        gameState.draggingElement = creatureElement;
                        gameState.draggedCreatureId = creature.id;
                        e.dataTransfer.setData('text/plain', creature.id);
                        e.dataTransfer.effectAllowed = 'copyMove';
                        setTimeout(() => creatureElement.classList.add('opacity-50'), 0);
                    });
                    creatureElement.addEventListener('dragend', () => {
                        gameState.draggingElement = null;
                        gameState.draggedCreatureId = null;
                        creatureElement.classList.remove('opacity-50');
                    });
                    creaturesContainer.appendChild(creatureElement);
                });
        }

        function createCreatureElement(creature, isOnCanvas = true) {
            const container = document.createElement('div');
            container.className = 'relative';
            container.dataset.creatureId = creature.id;
            container.dataset.creatureName = creature.name;
            const icon = document.createElement('div');
            icon.className = 'creature-icon';
            icon.textContent = creature.emoji;
            icon.title = creature.name;
            const name = document.createElement('div');
            name.className = 'text-xs text-center mt-1 whitespace-nowrap';
            name.textContent = creature.name;
            container.appendChild(icon);
            container.appendChild(name);
            return container;
        }

        function initCanvasDrop() {
            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
                canvas.classList.add('drop-zone-active');
                if (gameState.canvasCreatures.has(gameState.draggedCreatureId)) {
                    e.dataTransfer.dropEffect = 'move';
                } else {
                    e.dataTransfer.dropEffect = 'copy';
                }
            });
            canvas.addEventListener('dragleave', () => {
                canvas.classList.remove('drop-zone-active');
            });
            canvas.addEventListener('drop', (e) => {
                e.preventDefault();
                canvas.classList.remove('drop-zone-active');
                const creatureId = parseInt(e.dataTransfer.getData('text/plain'));
                if (isNaN(creatureId)) return;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left - 30;
                const y = e.clientY - rect.top - 30;
                if (gameState.canvasCreatures.has(creatureId)) {
                    const creatureState = gameState.canvasCreatures.get(creatureId);
                    creatureState.x = x;
                    creatureState.y = y;
                    creatureState.element.style.left = `${x}px`;
                    creatureState.element.style.top = `${y}px`;
                    updateConnections();
                    showStatus(`ç§»åŠ¨äº† ${creatureState.element.dataset.creatureName}`);
                    return;
                }
                const creature = creaturesData.find(c => c.id === creatureId);
                if (creature) {
                    const creatureElement = createCreatureElement(creature);
                    creatureElement.style.position = 'absolute';
                    creatureElement.style.left = `${x}px`;
                    creatureElement.style.top = `${y}px`;
                    canvas.appendChild(creatureElement);
                    gameState.canvasCreatures.set(creatureId, {
                        element: creatureElement,
                        x: x,
                        y: y
                    });
                    creatureElement.setAttribute('draggable', 'true');
                    creatureElement.addEventListener('dragstart', (e) => {
                        gameState.draggingElement = creatureElement;
                        gameState.draggedCreatureId = creatureId;
                        e.dataTransfer.setData('text/plain', creatureId);
                        e.dataTransfer.effectAllowed = 'copyMove';
                        setTimeout(() => creatureElement.classList.add('opacity-50'), 0);
                    });
                    creatureElement.addEventListener('dragend', () => {
                        gameState.draggingElement = null;
                        gameState.draggedCreatureId = null;
                        creatureElement.classList.remove('opacity-50', 'ring-2', 'ring-primary');
                    });
                    creatureElement.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        if (gameState.draggingElement && gameState.draggingElement !== creatureElement) {
                            creatureElement.classList.add('ring-2', 'ring-primary');
                            e.dataTransfer.dropEffect = 'copy';
                        }
                    });
                    creatureElement.addEventListener('dragleave', () => {
                        creatureElement.classList.remove('ring-2', 'ring-primary');
                    });
                    creatureElement.addEventListener('drop', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        creatureElement.classList.remove('ring-2', 'ring-primary');
                        const preyId = parseInt(e.dataTransfer.getData('text/plain'));
                        if (isNaN(preyId)) return;
                        const predatorId = parseInt(creatureElement.dataset.creatureId);
                        if (preyId === predatorId) {
                            showInfo(`ç”Ÿç‰©ä¸èƒ½æ•é£Ÿè‡ªå·±`);
                            return;
                        }
                        const predator = creaturesData.find(c => c.id === predatorId);
                        const prey = creaturesData.find(c => c.id === preyId);
                        if (predator && prey && predator.prey.includes(preyId)) {
                            const connectionKey = `${preyId}-${predatorId}`;
                            if (!gameState.connections.has(connectionKey)) {
                                gameState.connections.add(connectionKey);
                                createConnection(preyId, predatorId);
                                showInfo(`${prey.name} è¢« ${predator.name} æ•é£Ÿ`);
                            } else {
                                showInfo(`è¿™ç§æ•é£Ÿå…³ç³»å·²ç»å­˜åœ¨`);
                            }
                        } else {
                            showInfo(`${predator?.name || 'æœªçŸ¥ç”Ÿç‰©'} ä¸èƒ½æ•é£Ÿ ${prey?.name || 'æœªçŸ¥ç”Ÿç‰©'}`);
                        }
                    });
                    showStatus(`å·²æ·»åŠ  ${creature.name} åˆ°ç”»å¸ƒ`);
                }
            });
        }

        function createConnection(preyId, predatorId) {
            const prey = gameState.canvasCreatures.get(preyId);
            const predator = gameState.canvasCreatures.get(predatorId);
            if (!prey || !predator) return;
            let svg = document.querySelector('#canvas-svg');
            if (!svg) {
                svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.id = 'canvas-svg';
                svg.style.position = 'absolute';
                svg.style.top = '0';
                svg.style.left = '0';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.pointerEvents = 'none';
                svg.style.zIndex = '10';
                canvas.appendChild(svg);
            }
            const lineId = `connection-${preyId}-${predatorId}`;
            if (document.getElementById(lineId)) return;
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.id = lineId;
            line.setAttribute('stroke', '#165DFF');
            line.setAttribute('stroke-width', '2');
            line.dataset.preyId = preyId;
            line.dataset.predatorId = predatorId;
            updateLinePosition(line, preyId, predatorId);
            let defs = svg.querySelector('defs');
            if (!defs) {
                defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                svg.appendChild(defs);
            }
            if (!defs.querySelector('#arrowhead')) {
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.id = 'arrowhead';
                marker.setAttribute('viewBox', '0 0 10 10');
                marker.setAttribute('refX', '8');
                marker.setAttribute('refY', '5');
                marker.setAttribute('markerWidth', '6');
                marker.setAttribute('markerHeight', '6');
                marker.setAttribute('orient', 'auto');
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', '0 0, 10 5, 0 10');
                polygon.setAttribute('fill', '#165DFF');
                marker.appendChild(polygon);
                defs.appendChild(marker);
            }
            line.setAttribute('marker-end', 'url(#arrowhead)');
            svg.appendChild(line);
        }

        function updateLinePosition(line, preyId, predatorId) {
            const prey = gameState.canvasCreatures.get(preyId);
            const predator = gameState.canvasCreatures.get(predatorId);
            if (!prey || !predator) return;
            const preyX = prey.x + 28;
            const preyY = prey.y + 28;
            const predatorX = predator.x + 28;
            const predatorY = predator.y + 28;
            const dx = predatorX - preyX;
            const dy = predatorY - preyY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance === 0) return;
            const startOffset = 28;
            const endOffset = 32;
            const startX = preyX + (dx / distance) * startOffset;
            const startY = preyY + (dy / distance) * startOffset;
            const endX = predatorX - (dx / distance) * endOffset;
            const endY = predatorY - (dy / distance) * endOffset;
            line.setAttribute('x1', startX);
            line.setAttribute('y1', startY);
            line.setAttribute('x2', endX);
            line.setAttribute('y2', endY);
        }

        function updateConnections() {
            const svg = document.querySelector('#canvas-svg');
            if (!svg) return;
            const lines = svg.querySelectorAll('line');
            lines.forEach(line => {
                const preyId = parseInt(line.dataset.preyId);
                const predatorId = parseInt(line.dataset.predatorId);
                updateLinePosition(line, preyId, predatorId);
            });
        }

        function checkFoodChain() {
            if (gameState.canvasCreatures.size === 0) {
                showStatus('ç”»å¸ƒä¸Šæ²¡æœ‰ç”Ÿç‰©ï¼Œè¯·æ·»åŠ ç”Ÿç‰©åå†æ£€æŸ¥');
                return;
            }
            const currentLevel = levels[gameState.currentLevel - 1];
            const requiredCreatures = currentLevel.creatureIds;
            const canvasCreatureIds = Array.from(gameState.canvasCreatures.keys());
            const missingCreatures = requiredCreatures.filter(id => !canvasCreatureIds.includes(id));
            if (missingCreatures.length > 0) {
                const missingNames = missingCreatures.map(id => creaturesData.find(c => c.id === id)?.name || 'æœªçŸ¥ç”Ÿç‰©').join(', ');
                showStatus(`è¯·æ·»åŠ ä»¥ä¸‹ç”Ÿç‰©: ${missingNames}`);
                return;
            }
            const foodWeb = new Map();
            requiredCreatures.forEach(id => {
                foodWeb.set(id, { prey: new Set(), predators: new Set() });
            });
            gameState.connections.forEach(connection => {
                const [preyId, predatorId] = connection.split('-').map(Number);
                if (foodWeb.has(preyId) && foodWeb.has(predatorId)) {
                    foodWeb.get(predatorId).prey.add(preyId);
                    foodWeb.get(preyId).predators.add(predatorId);
                }
            });
            const producers = requiredCreatures.filter(id => creaturesData.find(c => c.id === id)?.type === 'producer');
            const consumers = requiredCreatures.filter(id => creaturesData.find(c => c.id === id)?.type === 'consumer');
            if (hasCycle(foodWeb)) {
                showStatus('é£Ÿç‰©é“¾ä¸­å­˜åœ¨å¾ªç¯ï¼Œè¿™æ˜¯ä¸åˆç†çš„');
                playSound(false);
                return;
            }
            let allConsumersHaveFood = true;
            consumers.forEach(id => {
                const creature = creaturesData.find(c => c.id === id);
                const possiblePrey = creature.prey.filter(preyId => requiredCreatures.includes(preyId));
                // A consumer is valid if it has no possible prey in this level, or if it has established a food source.
                const hasFood = possiblePrey.length === 0 || possiblePrey.some(preyId => foodWeb.get(id).prey.has(preyId));
                if (!hasFood) {
                    allConsumersHaveFood = false;
                    showStatus(`${creature.name} æ²¡æœ‰é£Ÿç‰©æ¥æº`);
                }
            });
            if (!allConsumersHaveFood) {
                playSound(false);
                return;
            }
            let hasProducerConsumerConnection = false;
            if (consumers.length > 0 && producers.length > 0) {
                 producers.forEach(producerId => {
                    if (foodWeb.get(producerId).predators.size > 0) {
                        hasProducerConsumerConnection = true;
                    }
                });
                if (!hasProducerConsumerConnection) {
                     showStatus('è¯·è¿æ¥ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…');
                     playSound(false);
                     return;
                }
            }
            showStatus('æ­å–œï¼æ‚¨å·²æ„å»ºäº†ä¸€ä¸ªæœ‰æ•ˆçš„é£Ÿç‰©é“¾');
            playSound(true);
        }

        function hasCycle(foodWeb) {
            const visited = new Set();
            const recursionStack = new Set();
            function dfs(node) {
                if (!visited.has(node)) {
                    visited.add(node);
                    recursionStack.add(node);
                    const predators = Array.from(foodWeb.get(node).predators);
                    for (const predator of predators) {
                        if (!visited.has(predator)) {
                            if (dfs(predator)) return true;
                        } else if (recursionStack.has(predator)) {
                            return true;
                        }
                    }
                }
                recursionStack.delete(node);
                return false;
            }
            for (const node of foodWeb.keys()) {
                if (dfs(node)) return true;
            }
            return false;
        }

        function playSound(isSuccess) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                if (isSuccess) {
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.5);
                } else {
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.3);
                }
                gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + (isSuccess ? 0.5 : 0.3));
                oscillator.start();
                oscillator.stop(audioContext.currentTime + (isSuccess ? 0.5 : 0.3));
            } catch (e) {
                console.error('æ— æ³•æ’­æ”¾éŸ³æ•ˆ:', e);
            }
        }

        function showStatus(message) {
            statusBar.textContent = message;
            statusBar.className = 'text-gray-700';
            setTimeout(() => {
                if (statusBar.textContent === message) {
                    statusBar.textContent = 'å‡†å¤‡å°±ç»ª';
                    statusBar.className = 'text-gray-500';
                }
            }, 3000);
        }

        function showInfo(message) {
            infoPanel.classList.remove('hidden');
            infoPanel.classList.add('flex');
            setTimeout(() => {
                infoPanel.classList.add('hidden');
                infoPanel.classList.remove('flex');
            }, 3000);
        }

        function initEventListeners() {
            checkBtn.addEventListener('click', checkFoodChain);
            window.addEventListener('resize', updateConnections);
        }

        function initGame() {
            initLevelSelector();
            updateCreaturesContainer();
            initCanvasDrop();
            initEventListeners();
            levelInfo.textContent = `å½“å‰å…³å¡: ç¬¬${gameState.currentLevel}å…³`;
            showStatus('æ¸¸æˆå·²å‡†å¤‡å°±ç»ª');
        }
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>